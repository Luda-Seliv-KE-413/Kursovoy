:imagesdir: images
:toc: macro
:icons: font
:figure-caption: Рисунок
:table-caption: Таблица
:stem: Формула


== Дизайн

=== Настройка подключения датчика температуры

* Подключить датчик температуры к интерфейсу I2C.
* Включить внцтренний АЦП (удатчика).
* При использовании серверов LM75 в качестве подчиненного устройства спользуется 7-разрядный адрес подчиненного устройства.

[#7-разрядный адрес]
.7-разрядный адрес
image::dlay temp.png[]

Пины А2/А1/А0 этогомодуля подключены к земле поэтому адрес подчиненного устройства здесь равен 0х48.

=== Настройка подключения таймперов TIM2 и TIM5

* Таймеры тактируются от шины APB1.

* Подключение к системе тактирование выполняется через регистр APB1ENR модуля RCC.

* Входную частоту таймера можно поделить, записав делитель частоты в решистр PSC.

* Включение таймера производиться с помощью бита CEN в регистре CR1 модуля таймера.

//На каждый отчсет таймера по умолчанию происходит на частоте шины, т.е. если шина APB1 работает на частоте 1 Мгц, то один отсчет таймера произойдет через 1 мкс. Таким образом можно организовать измерение времени с разрешением в 1 мкс.

Так как резнатор работает в диапазоне частот 32 000...45 000 кГц для того, чтобы таймер не вышелиз строя и чтобы не потерять точность при измерении частоты необходимо произвести некоторые настройки для захвата сигнала и как следствие измерение частоты.

*Метод: захват с помощью ETR2*

 При настройке источника тактирования таймера можно выбрать вывод ETR2 (External Trigger Input 2), и тогда таймер в качестве источника тактирования будет использовать внешний источник. На этот вывод будет подаваться измеряемый сигнал.

_Реализация частотомера второго рода._ 

Основной принцип работы частотомера второго рода заключается в сравнении частоты входящего сигнала с частотой, генерируемой внутри прибора, в данном случае длительность периода внешнего сигнала будет измеряться в количестве тиков другого таймера.

Заводим TIM2, который просто считает импульсы с максимально возможной частотой. По приходу первого импульса на ETR2 запускается TIM5. Когда на TIM2 придет, конечный импульс (заранее заданный), фиксируем, сколько импульсов насчитал TIM5. Делим это значение на число импульсов и получаем период захватываемого сигнала. 

==== Настройка TIM2

ТIM2 отвечает за периодичность измерений, то есть

//******************************************************/
Настройка проекта: настроим таймера 2, на который будет подаваться входной сигнал. Считает до 100го импульса, а потом счет сбрасывается и начинается новый период. Именно в этот момент мы будем фиксировать кол-во отсчитанного времени на 100 периодов входного сигнала.


Настройка таймера 4 для отсчета времени:


У обоих таймеров необходимо включить прерывание. Переходим к коду: создаем глобальные переменные:

/* USER CODE BEGIN PV */
volatile uint16_t num_per_tim = 0;    // кол-во прошедших периодов таймера
volatile uint16_t time_tim = 0;       // сюда будем записывать время с таймера, когда при-шел 10 импульс
volatile uint16_t per_tim = 0;        // сюда будем записывать кол-во периодов таймера
volatile uint8_t  flag_data = 0;      // по этому флагу будем отслеживать момент, когда пора считать значение частоты
Создаем callback для обработки данных. Суть в том, что таймер 4 считает с частотой больше частоты входного сигнала и будет много раз переполняться. Кол-во переполнений таймера 4 как раз и будем хранить в переменной num_per_tim, поэтому в callback таймера 4 необходимо каждый раз инкрементировать счетчик периодов таймера. А в callback таймера 2 программа будет попадать, когда пришли все 100 импульсов и будет фиксироваться затраченное количество импульсов таймера 4.

/* USER CODE BEGIN 4 */
/*----------------------------------------------------------------------------*/
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	// если таймер досчитал до конца, не получив все 100 импульсов на вход Timer 2 ETR2, то увеличиваем счетчик кол-ва периодов
	if (htim->Instance == TIM4)
		num_per_tim++;
	if (htim->Instance == TIM2)
	{
		time_tim = __HAL_TIM_GET_COUNTER(&htim4);
		per_tim  = num_per_tim;
		num_per_tim = 0;                                   // сброс счетчика периодов
		TIM4->CNT = 0;                                     // сброс счета таймера
		flag_data = 1;
	}
}
Теперь, отслеживая состояние flag_data можно считать частоту:

В начале вычисляем суммарное потраченное время, а затем делим его на 100 и вуаля, значение частоты готово. Подадим на вывод PA0 сигнал с частотой 10 кГц:

//******************************************************/

* Подключение к системе тактирование выполняется через регистр APB1ENR модуля RCC.

* Входную частоту таймера можно поделить, записав делитель частоты в решистр PSC.

* Включение таймера производиться с помощью бита CEN в регистре CR1 модуля таймера.

=== Настройка подключения интерфейса USART2 для Bluetooth

* Подключить USART к источнику тактирования – устанавливаем бит USART2EN в регистре APB1ENR (АЦП тактируется от матрицы шин APB1).​
* Необходимо сконфигурировать порты. Настроить порты, на альтернативную функцию нужного модуля USART​
* Настроить формат передачи байт, с помощью регистра CR1 и CR2​
* Задать скорость передачи с помощью регистра BRR​
* Разрешить передачу помощью бита TE и если надо прием, с помощью бита RE в модуле USART с помощью регистра CR1​
* Включить сам модуль USART битом UE  в регистре CR1​
* Если работаем через прерывание, то разрешить глобальное прерывание для нужного USART, в регистре ISER[1] модуля NVIC​
* Если работаем через прерывание, в зависимости от того, что нам нужно, разрешить прерывание по сигналу модуля UART (например,
  от сигнала регистр данных передачика пуст (бит TXEIE в регистре CR1))


=== Архитектура
По полученным результатам анаализа требований и необходимым настройкам была составлена архитектура программного обеспечения устройства.

include::Diagram.puml[]
